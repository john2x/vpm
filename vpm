#!/usr/bin/python
import datetime
import time
import argparse
import os
import sys
import ConfigParser
import urllib
import json
import subprocess
import shutil

VERSION = '0.0.1'
DEBUG = True
DEFAULT_PATHOGEN_PATH = os.path.expanduser('~/.vim/bundle')
VPM_HOME = os.path.expanduser('~/.vpm')
VPM_BUILD_DIR = os.path.join(VPM_HOME, 'build')
VPM_CONFIG_FILE = os.path.join(VPM_HOME, 'vpmrc')
VPM_REPO_FILE = os.path.join(VPM_HOME, '.repos')
VPM_INSTALLED_PLUGINS_FILE = os.path.join(VPM_HOME, '.installed_plugins')
VIM_SCRIPTS_REPOS = 'https://api.github.com/users/vim-scripts/repos'
VIM_SCRIPTS_REPO = 'https://api.github.com/repos/vim-scripts/'

def config(args):
    # create vpm home
    if not os.path.exists(VPM_HOME):
        os.mkdir(VPM_HOME)
    if not os.path.exists(VPM_BUILD_DIR):
        os.mkdir(VPM_BUILD_DIR)
    if not os.path.exists(VPM_INSTALLED_PLUGINS_FILE):
        with open(VPM_INSTALLED_PLUGINS_FILE, 'wb') as installed:
            installed.write('{}')
    # ask where Pathogen's bundle directory is
    pathogen_path = raw_input('Specify your Pathogen "bundle" directory (Leave blank to use ~/.vim/bundle): ')
    pathogen_path = pathogen_path.strip()
    if pathogen_path == '':
        pathogen_path = DEFAULT_PATHOGEN_PATH
    if not os.path.exists(os.path.expanduser(pathogen_path)):
        raise ValueError('pathogen_path "%s" does not exist.' % pathogen_path)

    # update config file
    cp = ConfigParser.ConfigParser()
    cp.add_section('Pathogen')
    cp.set('Pathogen', 'pathogen_path', os.path.expanduser(pathogen_path))

    git = _git()
    if not git:
        print 'git command not found'
        return 1

    cp.add_section('Git')
    cp.set('Git', 'git', git)
    with open(VPM_CONFIG_FILE, 'wb') as config_file:
        cp.write(config_file)
    #if (not os.path.exists(os.path.expanduser(VIM_SCRIPTS_REPOS)) or
    #    (datetime.datetime.now() - time.ctime(os.path.getctime(os.path.expanduser(VIM_SCRIPTS_REPOS)))) > datetime.timedelta(hours=6)):
    #    print 'Updating vim-scripts.org cached repository...'
    #    _cache_vim_scripts()
    return 0

def _cache_vim_scripts():
    # TODO: repos list is paginated
    repos = urllib.urlopen(VIM_SCRIPTS_REPOS)
    repos = json.load(repos)
    repos_clean = {}
    for repo in repos:
        name = repo['name']
        description = repo['description']
        url = repo['clone_url']
        repos_clean[name] = [description, url]
    with open(VPM_REPO_FILE, 'wb') as repo_file:
        json.dump(repos_clean, repo_file)

def _search_cache(plugin_name):
    plugin_name = args.plugin_name
    with open(VPM_REPO_FILE, 'r') as repo_file:
        repos = json.load(repo_file)
    results = []
    plugin_name == plugin_name.lower()
    for k, v in repos.items():
        if plugin_name in k.lower():
            desc, url = v
            results.append((k, desc, url))
    return results

def _search_vim_scripts(plugin_name):
    repo = urllib.urlopen(VIM_SCRIPTS_REPO + plugin_name)
    repo = json.load(repo)
    if repo.get('message') == 'Not Found':
        return None, None, None
    return repo['name'], repo['description'], repo['clone_url']

def _get_installed_plugin(plugin_name):
    plugins = {}
    with open(VPM_INSTALLED_PLUGINS_FILE, 'rb') as installed:
        try:
            plugins = json.load(installed)
        except ValueError:
            pass
    plugin_name = plugin_name.lower()
    for k, v in plugins.items():
        if plugin_name == k.lower():
            # verify plugin is still in install path
            if not os.path.exists(v[1]):
                return None
            return k, v[0], v[1]
    return None

def _is_installed(plugin_name):
    plugin = _get_installed_plugin(plugin_name)
    return bool(plugin)

def _which_git():
    try:
        git = subprocess.check_output(['which', 'git'])
    except subprocess.CalledProcessError:
        return None
    return git.strip()

def _git():
    cp = ConfigParser.ConfigParser()
    with open(VPM_CONFIG_FILE, 'rb') as config:
        cp.readfp(config)
    if cp.has_section('Git'):
        return cp.get('Git', 'git')
    return _which_git()

def _bundle_path():
    cp = ConfigParser.ConfigParser()
    with open(VPM_CONFIG_FILE, 'rb') as config:
        cp.readfp(config)
    if not cp.has_section('Pathogen'):
        print 'No section'
        print "pathogen_path not found. Run 'vpm configure' first."
        return None
    pathogen_path = cp.get('Pathogen', 'pathogen_path')
    if not pathogen_path:
        print 'No get'
        print "pathogen_path not found. Run 'vpm configure' first."
        return None
    return pathogen_path

def _cleanup():
    print 'Cleaning up...'
    shutil.rmtree(VPM_BUILD_DIR)
    os.mkdir(VPM_BUILD_DIR)

def _clone(plugin_name, clone_url, bundle_path):
    git = _git()
    if not git:
        'git not found'
        return
    git_command = (
        git, 'clone',
        clone_url, os.path.join(VPM_BUILD_DIR, plugin_name),
    )
    print 'Cloning %s...' % clone_url
    try:
        pr = subprocess.check_call(git_command)
        return True
    except subprocess.CalledProcessError, e:
        return False

def _clone_and_move(plugin_name, clone_url):
    bundle_path = _bundle_path()
    if bundle_path is None:
        print "Pathogen bundle directory not found. Run 'vpm configure' first."
        return
    if not _clone(args.plugin_name, clone_url, bundle_path):
        return None
    install_path = os.path.join(bundle_path, plugin_name)
    shutil.rmtree(install_path, True)
    shutil.copytree(os.path.join(VPM_BUILD_DIR, plugin_name),
                    install_path)
    print 'Copying to Pathogen bundle directory %s...' % bundle_path
    return install_path

def _remove_plugin(plugin_name):
    bundle_path = _bundle_path()
    install_path = os.path.join(bundle_path, plugin_name)
    shutil.rmtree(install_path, True)
    return install_path

def _update_installed_plugin_list(plugin_name, clone_url, clone_path):
    plugins = {}
    with open(VPM_INSTALLED_PLUGINS_FILE, 'rb') as installed:
        try:
            plugins = json.load(installed)
        except ValueError:
            pass
    plugins[plugin_name] = (clone_url, clone_path)
    with open(VPM_INSTALLED_PLUGINS_FILE, 'wb') as installed:
        json.dump(plugins, installed)

def _cleanup_installed_plugin_list(plugin_name):
    plugins = {}
    with open(VPM_INSTALLED_PLUGINS_FILE, 'rb') as installed:
        try:
            plugins = json.load(installed)
        except ValueError:
            pass
    if plugin_name in plugins.keys():
        plugins.pop(plugin_name)
    with open(VPM_INSTALLED_PLUGINS_FILE, 'wb') as installed:
        json.dump(plugins, installed)

def _is_pathogen_compatible(path):
    pass

def list_installed(args):
    plugins = {}
    with open(VPM_INSTALLED_PLUGINS_FILE, 'rb') as installed:
        try:
            plugins = json.load(installed)
        except ValueError:
            return
    for name, plugin_info in plugins.items():
        print '%s (%s)' % (name, plugin_info[1])

def search(args):
    name, description, url = _search_vim_scripts(args.plugin_name)
    if not name:
        print args.plugin_name + ' not found'
        return
    print '%s - %s (%s)' % (name, description, url)

def install(args):
    _, _, clone_url = _search_vim_scripts(args.plugin_name)
    if not clone_url:
        print args.plugin_name + ' not found'
        return
    # check if plugin isn't already installed
    if _is_installed(args.plugin_name):
        print "%s already installed. Run 'vpm update %s' to update instead." % (
            args.plugin_name, args.plugin_name)
        return
    print 'Installing %s...' % args.plugin_name
    install_path = _clone_and_move(args.plugin_name, clone_url)
    if not install_path:
        print 'Failed to install %s.' % args.plugin_name
        return
    _update_installed_plugin_list(
        args.plugin_name, clone_url, install_path)
    _cleanup()
    print 'Successfully installed %s.' % args.plugin_name

def update(args):
    # check if plugin is installed
    if not _is_installed(args.plugin_name):
        print "%s not installed. Run 'vpm install %s' to install." % (
            args.plugin_name, args.plugin_name)
        return
    _, clone_url, install_path = _get_installed_plugin(args.plugin_name)
    # clone repo
    print 'Updating %s...' % args.plugin_name
    install_path = _clone_and_move(args.plugin_name, clone_url)
    if not install_path:
        print 'Failed to update %s.' % args.plugin_name
        return
    _update_installed_plugin_list(
        args.plugin_name, clone_url, install_path)
    _cleanup()
    print 'Successfully updated %s.' % args.plugin_name

def uninstall(args):
    print 'Uninstalling %s...' % args.plugin_name
    install_path = _remove_plugin(args.plugin_name)
    if not install_path:
        print 'Failed to uninstall %s.' % args.plugin_name
        return
    _cleanup_installed_plugin_list(args.plugin_name)
    _cleanup()
    print 'Successfully removed %s.' % args.plugin_name

p = argparse.ArgumentParser(description='Vim Plugin Manager (ALPHA)')
p.add_argument('--version', action='version', version='%(prog)s ' + VERSION)
sp = p.add_subparsers()

config_p = sp.add_parser('configure')
config_p.set_defaults(func=config)

list_installed_p = sp.add_parser('list-installed')
list_installed_p.set_defaults(func=list_installed)

search_p = sp.add_parser('search')
search_p.add_argument('plugin_name')
search_p.set_defaults(func=search)

install_p = sp.add_parser('install')
install_p.add_argument('plugin_name')
install_p.set_defaults(func=install)

install_p = sp.add_parser('update')
install_p.add_argument('plugin_name')
install_p.set_defaults(func=update)

install_p = sp.add_parser('uninstall')
install_p.add_argument('plugin_name')
install_p.set_defaults(func=uninstall)

if __name__ == '__main__':
    args = p.parse_args()
    args.func(args)

